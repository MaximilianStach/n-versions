%
In den vorherigen Kapiteln wurde Konzepten, Eigenschaften und Kritikpunkte der N-Version Programmierung vorgestellt.
Potentielle Stärken und Schwächen dieses und anderer Ansätze zur Zuverlässigkeit von Software-Systemen werden in Kapitel \ref{vergleich} entgegengesetzt. 
Weiterhin werden in Kapitel \ref{bewertung-relevanz} mögliche Einsatzmöglichkeiten der N-Version Programmierung für aktuelle Felder der Software-Entwicklung vorgestellt.
%
\subsection{Bewertung}\label{vergleich}
Erhöhter Aufwand bei der Entwicklung von Software im Hinblick auf fehlerfreie Ausführung ist besonders in sicherheitskritischen Problemfeldern, bei denen auftretende Fehler zu fatalen Folgen führen können, sinnvoll.
Um zuverlässige Ausführung von Programmen zu Erreichen gibt es zwei verschiedene Ansätze \cite{Avizienis:1975:FFC:800027.808469}. Eine Möglichkeit besteht in dem Bestreben möglichst alle Fehler vor dem produktiven Einsatz zu eliminieren. Intensiven Tests des Zielprogramms, standardisierten Methoden des Software-Designs und die Wahl von höheren Programmiersprachen zählen zu den Herangehensweisen. Jedoch hat sich anhand vieler fataler Fehler in der Geschichte der Programmierung gezeigt, dass trotz aller Bemühungen keine absolute Zuverlässigkeit garantiert werden kann. Das alternative Verfahren dazu liegt im Versuch Fehlertoleranz bei der Ausführung von Programmen zu erzielen. Falls Fehler auftreten, werden diese durch redundante Strukturen aufgefangen und spiegeln sich nicht im weiteren Ablauf oder in den Ergebnissen der Programme wider. N-Version Programmierung als Ansatz zur Fehlertoleranz ermöglicht in der Theorie durch die parallele Entwicklungsmöglichkeiten kürzere Entwicklungszeiten als intensiv getestete Programme, welche lediglich aus einer Version bestehen. Durch die erhöhte Anzahl der beteiligten Entwicklerteams würden hingegen auch hier höhere Kosten vorhanden sein. Die Studienlage zur Effektivität der N-Version Programmierung im Hinblick auf Kosten und Zuverlässigkeitsgewinn ist uneindeutig. Obwohl eine höhere Zuverlässigkeit durch N-Version Programmierung erzielt werden konnte, ergaben Experimente, dass die Annahme der Unabhängigkeit der auftretenden Fehler in verschiedenen Versionen nicht in jedem Fall gegeben ist \cite{Knight:1986:EEA:10677.10688} und multiversionale Programmierung nicht als Ersatz für ausgiebiges funktionales Testen herhält \cite{Shimeall:1991:ECS:104878.104899}. Außerdem wurde gezeigt, dass bereits geringe Wahrscheinlichkeiten für korrelierte Fehler in den Ergebnissen der Versionen zu einer wesentlichen Reduktion der potentiellen Zuverlässigkeitssteigerung führen \cite{Eckhardt:1985:TBA:1314034.1314066}.
Weitere Ansätze sind neben der Recovery-Block-Technik unter anderem \enquote{Concurrent Error Detection} und \enquote{Algorithmic Fault-tolerance} \cite{229487}. Alle haben gemein, dass sie für bestimmte Problemstellungen besser geeignet sind und unterschiedliche Qualitäten zur Fehlerentdeckung- und Vermeidung haben. Teilweise wird eine Balance zwischen Bestrebungen zur Fehlervermeidung- und Toleranz vorgeschlagen \cite{Avizienis:1975:FFC:800027.808469}.
%
\subsection{Aktuelle Relevanz}\label{bewertung-relevanz}
Aktuellere Studien widmen sich erneut dem Ansatz der multiversionalen Software-Entwicklung, jedoch diesmal verstärkt mit der Absicht die Sicherheit von Programmen gegen mutwillige Angriffe zu erhöhen \cite{current-challenges}. Diversität lediglich auf der Ebene der Implementation wird als nicht ausreichend eingestuft und zusätzlich verstärkt, wie durchaus ursprünglich gefordert, auf die Ebene der Programmiersprachen fokussiert. Obwohl die Hypothese der Fehlerunabhängigkeit nicht bestätigt wurde, so konnte doch eine wesentlich höhere Zuverlässigkeit durch den Einsatz von Diversität erzielt werden.
Da eine häufige Kategorie von Fehlern in multiversionalen Programmen auf Missverständnisse in der Interpretation der gemeinsamen Spezifikation zurückzuführen sind, wird zunehmend die Forderung der N-Version Programmierung nach isolierten Programmiertätigkeiten diskutiert. Wären Diskussionen unter den verschiedenen Entwicklerteams über die Interpretation der Spezifikation nicht verboten sondern erwünscht, könnte diese Art der Fehler deutlich reduzieren. Weiterhin wird gefordert, dass gezielt die Diversität der Programme durch Wahl unterschiedlicher Programmiersprachen und bereitstellen verschiedener Spezifikationen erhöht werden sollte. 
Auch werden Internetapplikationen vermehrt als Einsatzgebiet der N-Version Programmierung erforscht. Eine Cloud-basierte Antiviren-Software konnte beispielsweise durch die Verwendung mehrerer heterogener Virenerkennungssysteme eine Steigerung der Entdeckungsrate von aktuellen Viren um $35\%$ im Vergleich zu herkömmlichen Systemen verzeichnen \cite{Oberheide:2008:CNA:1496711.1496718}. Dass selbst das Generieren des HTML-Quelltextes von Websiten und das damit verbundene Backend mit N-Version Programmierung umgesetzt werden kann zeigte ein weiteres Experiment \cite{zero-day}. 
Dabei wurden 3 Versionen eines Online-Auktionshauses mit je verschiedenen Betriebsystemen, Webservern, Programmiersprachen und Datenbankmanagementsystemen implementiert. Es sollte die Sicherheit im Hinblick auf 10 typische Schwachstellen von Web-Applikationen, die besonders von Zero-Day-Exploits geprägt sind, verbessert werden. Da Zero-Day-Exploits meist plattform- oder programmiersprachenspezifisch sind, ist anzunehmen, dass sie nur in einer der 3 Versionen auftreten. Schwachstelle dabei bleibt jedoch der notwendige gemeinsame Verteiler und Treiber der HTTP-Anfragen. Dieser muss zusätzlich zum Verteilen der Anfragen die Session des Benutzers mit der Website verwalten und fehlgeschlagene Anfragen protokollieren.
Dieser Verteiler kann selbst zum Ziel von Attacken werden und falls kompromittiert, Transaktionen im Namen eines anderen Benutzers tätigen.